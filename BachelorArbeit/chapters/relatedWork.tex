\chapter{Verwandte Arbeiten}\vspace{1cm}
In der Informatik spielt das Thema Energieverbrauch eine besonders gro\ss e Rolle. Es existieren daher bereits viele Ans\"atze und neue Verfahren zum effizienten Umgang mit der knappen Ressource Strom. Die in diesem Kapitel diskutierten Ans\"atze fussen auf vergangenen Studien die zeigten, dass viele Programme fehlertolerant gegen\"uber geringf\"ugigen Fehlermengen sind \cite{correctness}. Verschiedene Anwendungen machen sich dieses Verhalten zunutze und erzielen mit der Differenzierung zwischen fehlerbehafteten und fehlerfreien Daten erstaunliche Ergebnisse.\\ 
Das entwickelte Programm dieser Bachelorarbeit, soll bei der Identifikation von fehlerbehafteten Daten eingesetzt werden. Konkret bearbeitet die Anwendung Datenströme, indem sie in deren Bytecode Fehlerwerte injiziert. Die Injektion geschieht \"uber die Markierung der fehlerbehafteten Streams durch eine bestimmte Annotation. Das Setzen der Fehlerwerte ist zur Laufzeit dynamisch m\"oglich, einzige Voraussetzung ist die gobale Deklaration der Streams. Die verwendete Annotation enth\"alt Parameter wie Fehlerrate, die Blockgr\"o\ss e und den Fehlertyp. Die Datensätze können somit auf ein akkurates Ma\ss {} mit Fehlern bzw. Datenverlusten injiziert werden. Letztendlich sollen dadurch Einsparungen bei der weiteren Bearbeitung erzielt und trotzdem das gew\"unschte Resultat geliefert werden. Solche Fehlerinjektionen wurden bereits in verschiedenen Anwendungen auf unterschiedlicher Weise eingef\"uhrt. 


\section{EnerJ}
Eine dieser Anwendungen, mit vergleichbarer Funktionalit\"at, ist EnerJ das eine Erweiterung der Programmiersprache Java bietet. EnerJ nutzt f\"ur die Unterscheidung zwischen fehlerfreien und fehlerbehafteten Elementen eindeutige Annotationen, welche als type-qualifier eingesetzt werden. Fehlerfreie Datentypen werden in EnerJ durch eine @Precise Annotation gekennzeichnet. Eine Annotierung präziser Datentypen ist allerdings optional, da der Default-Wert @Precise ist. Die Kennzeichnung fehlerbehafteter  Datentypen geschieht über eine @Approx Annotation. Auch in dieser Bachelorarbeit wurden Annotationen zur Fehlermarkierung eingesetzt. Ein wesentlicher Unterschied liegt in der Verwendung der Annotationen. Während EnerJ allgemeine Datentypen als approximiert oder exakt deklariert, sind die Annotationen dieser Bachelorarbeit, auschlie\ss lich auf eine variable Fehlerinjektion in Datenströmen ausgelegt.  \\
Die Korrektheit der Daten kann in EnerJ, nur bei den pr\"azisen/fehlerfreien Daten garantiert werden. Approximierte Daten haben diese Garantie nicht. Dies resultiert aus dem Grundsatz das ein Datentyp entweder pr\"azise oder approximiert sein kann. Es gibt keine verschiedenen Ebenen der Approximation, so das auch keine Garantie bzgl. der Fehlergrenzen gegeben werden kann \cite{EnerJ11}. In dieser Bachelorarbeit wurden dagegen verschiedene Ebenen eingef\"uhrt. Die Fehlerwerte der \courier{FaultInj} Annotation k\"onnen beliebig gewählt und auch zur Laufzeit angepasst werden. \\
F\"ur die Implementierung von EnerJ wurde auf das Checker Framework von Papi et al. \cite{checkerframework} zur\"uckgegriffen. Dieses erweitert das Java Typ-System und macht es um einiges vielseitiger. Es besteht aus Compiler Plug-ins sogenannten ``checkers'' und ist flexibel um weitere Compiler Plug-ins erweiterbar. Das Framework bringt einen besonderen Vorteil f\"ur die Fehlermarkierung mit sich. Indem es auch Annotationen für lokal definierte Variablen erlaubt, beitet es einen großen Handlungsspielraum. Lokale Annotationen sind ursp\"unglich nur zur Auswertung f\"ur den Compiler vorgesehen und finden aus diesem Grund in meiner Implementierung keine Anwendung. Auf die Verwendung des Checker Frameworks habe ich jedoch bewusst verzichtet, da die Verwendung dieser Technologie eine erhebliche Laufzeitverschlechterung mit sich bringt.

\section{Green-Framework}
Ein weiterer \"ahnlicher Ansatz findet sich im Green-Framework von Woongki Baek und Trishul M. Chilimbi. Diese Anwendung bietet ein flexibles Framework, welches versucht un\"otige Genauigkeiten durch Approximationen zu kompensieren. Das Framework fokusiert sich dabei allerdings auf Approximationen f\"ur Schleifen und Funktionen, wodurch es sich von meiner Implementierung bereits abgrenzt. Jedoch bietet es ebenfalls verschiedene Ebenen der Fehlerinjektion. Der Entwickler hat die M\"oglichkeit einen maximalen Verlust bez\"uglich der Anforderungen/QoS\footnote{Quality of Service} anzugeben. Das Green-Framework liefert im Anschluss eine Auswertung, inwieweit die Anwendung diesen Anforderung gen\"ugen wird. Um approximierte Funktionen nutzen zu k\"onnen, muss der Entwickler diese zus\"atzlich bereitstellen. Schleifen k\"onnen beispielsweise durch weniger Iterationen approximiert werden. Am Ende erstellt der Green Compiler, auf Grundlage eines generierten QoS-Models mit dem ursp\"unglichen Programm, eine energieeffizientere Anwendung mit den approximierten Funktionen \cite{green}. 

\section{Probabilistic Accuracy Bounds}
Die Arbeit von Martin Rinard, ``Probabilistic Accuracy Bounds for Fault-Tolerant
Computations that Discard Tasks'' besch\"aftigt sich ebenfalls mit einer Methode die es erm\"oglicht,  Berechnungen mit Datenfehlern auszuführen und dennoch einen vern\"unftigen Output zu erzeugen. \\ 
Die Berechnungen werden bei diesem Ansatz in einzelne Tasks eingeteilt. Bei der Ausf\"uhrung werden Tasks, bei denen Fehler bzw. St\"orungen vorhanden waren, einfach verworfen. Die fehlerfreien Tasks setzen die Berechnung bis zum Ende fort. Das Modell verwendet als Grundlage zuf\"allige Ausf\"uhrungen eines Programms mit unterschliedlichen Task-Fehlerraten. Anhand dieser Ausführungen wird ein quantitatives, probabilistisches Modell erstellt. Das Modell charakterisiert die Verzerrung des Outputs. Durch die somit definierten Grenzen, leistet die Anwendung trotz Fehlern einen qualitativen Output. Weiterhin ist die Erstellung eines Timing-Modells\footnote{Ausf\"uhrungszeit als Funktion über Task Fehlerraten} vorgesehen. Die Kombination der beiden Modelle erlaubt es die Genauigkeit der Ausf\"uhrung zu reduzieren. Die Fehlerinjektion wird bei diesem Ansatz durch eine Injektion mit fehlerhaften Tasks vogenommen. Dadurch lässt sich Ausf\"uhrungszeit sparen, w\"ahrend die Abweichung der Berechung innerhalb akzeptabler Grenzen liegt \cite{Rinard06}. 

\section{Loop Perforation}
Eine weitere Technik, um die Genauigkeit einer Anwendung zu reduzieren und damit einen Leistungszuwachs zu erzielen, ist die ``loop perforation'' von Stelios Sidiroglou-Douskos  et al.\\
Diese Anwendung versucht analog zum Green-Framework, eine bessere Performance durch effizientere Berechnungen in Schleifen zu erzielen. Im kern wird versucht die Anzahl der Iterationen von Schleifen zu reduzieren, um somit einen geringeren Rechenaufwand zu erhalten. Dieser Vorgang wird ``Perforierung'' genannt. Das Verfahren filtert f\"ur die Unterscheidung von fehlerfreien und fehlerbehafteten Daten zun\"achst die kritischen Schleifen heraus, dieser Vorgang nennt sich ``Criticality Testing''. Alle kritischen Schleifen, sind Schleifen die durch die Perforierung einen Schaden verursachen. Alle nicht kritischen Schleifen k\"onnen durch die Perforierung einen erheblichen Effizientzanstieg, bei einer weiterhin akzeptablen Genauigkeit erzielen. Die zweite Phase ist der ``Perforation Space Exploration'' Algorithmus. Alle nicht kritischen Schleifen werden in dieser Phase verarbeitet, indem versucht wird sie optimal zu kombinieren. Dadurch entsteht eine Menge von Pareto-optimalen\footnote{Zustand, in dem ein Individuum nicht besser gestellt werden kann} Varianten mit bestm\"oglicher Perfomance, bei einem bestimmten Genauigkeitsverlust \cite{loopPerforation}. Die Anwendung fokusiert sich im Gegensatz zu meiner Implementierung auf Schleifen. Die Fehlerinjektion beginnt beim Criticality Testing und wird anschlie\ss end algorithmisch optimiert. Die Optimierung wird grunds\"atzlich durch eine Reduzierung von Schleifeniterationen vorgenommen. Die Anwendung dieser Bachelorarbeit bietet bezieht sich ausschlie\ss lich auf Datenströme. Zusätzlich wird vielseitigerer Injektionsmechanismus mit diversen Fehlertypen und variabel anpassbarer Fehlerrate angeboten. 