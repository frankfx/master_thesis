\subsection{Fehlerwerte}
Fehlerwerte sind im Programmcode als Annotationen darstellt. Ein Stream kann dabei auch mit mehreren Annotationen versehen werden. Der Fehlerwert besteht immer aus den folgenden vier Komponenten:

\begin{itemize}
	\item ID: Die ID ist ein eindeutiger Wert zur Unterscheidung bzw. Identifikation der einzelnen Streams. Soll ein Fehlerwert dynamisch ver\"andert werden, wird dieser \"uber die ID angesprochen. Sie wird dementsprechend in der Implementierung gesetzt und kann w\"ahrend der Laufzeit nicht ver\"andert werden.
	\item Type: Der Fehlertyp wird \"uber den Parameter \courier{type} angesprochen. Er repr\"asentiert die Fehlerlogik die angewendet werden soll. Als m\"ogliche Typen stehen in dieser Version der Anwendung RANDOM, LOSS, ZERO, BITFLIP, BITFLIPB, NONE zu Verf\"ugung. Auf deren genauere Bedeutung wird in den folgenden Abschnitten der konkreten Logiken eingegangen.
	\item Rate: Die Fehlerrate ist eine Gleitkommazahl doppelter Genauigkeit und liegt zwischen 0 und 1. Sie gibt die Wahrscheinlichkeit der Injektion eines Blocks oder Bits an. Die Werte stehen für 0\% bis 100\% und flie\ss en in die Berechnung einer Zufallsfunktion ein. Diese  erstellt auf Grundlage der statischen Methode \courier{random} aus der Klasse \courier{Math} einen Zufallswert und setzt diesen in Relation zu der Fehlerrate. Das Ergbnis der Berechnung liefert die Entscheidung über die Injektion eines Blocks oder Bits, abhängig von der konkreten Strategie. Bei einer Fehlerrate von 1 würden demnach alle Blöcke oder Bits injiziert werden.
	\item Blocksize: Die Blockgr\"o\ss e bestimmt die Anzahl der zu injizierenden Bytes, die in einen Block gepackt werden sollen. Bis auf die einfache Bitflip Strategie sind alle Injektionsstrategien auf den Blocksize Parameter angewiesen. Die eben beschriebene Zufallsfunktion arbeitet f\"ur diese Logiken auf der Blockebene. Das hei\ss t die Zufallsentscheidung der Injektion wird nicht f\"ur einzelne Bytes, sondern f\"ur den gesamten Block getroffen.
\end{itemize}

\label{strats}
\subsection{Injektions-Strategie}

Die abstrakte Klasse \courier{InjectionStrategy} wurde als Oberklasse für alle konkreten Strategien definiert. Sie enthält keine eigene Injektionslogik, fordert aber die Implementierung einer Injektionslogik von ihren Unterklassen. Sie stellt ebenso die Zufallsfunktion als auch die Fehlerwerte für ihre Unterklassen zur Verfügung. In Abbildung \ref{StrategyUML} wurde dieses Muster, zuzügliche der Verbindung zur Klasse \courier{Context}, modelliert.

\begin{figure}[!htb] 
\centering
		\umlDiagram[box=,border,sizeX=12cm,sizeY=14cm,ref=pack]{	
			\umlClass[pos=\umlTop{pack}, stereotype=Class, posDelta={0, -1},
				refpoint=t]{Context}{}{}	
			\umlClass[pos=\umlTop{pack}, stereotype=Abstract Class, posDelta={0, -8},
				refpoint=t]{InjectionStrategy}{
					\umlAttribute[visibility=\# , type=FaultValue{[]}]{faults}				
				}{
					\umlMethod[visibility=+, type=void]{\textit{runInjection}}{}
					\umlMethod[visibility=\# , type=boolean]{isInject}{double}				
				}
			\umlClass[pos=\umlLeft{pack}, stereotype=Class, posDelta={5.5, 0},
				refpoint=t]{StrategyBitflip}{}{
					\umlMethod[visibility=+, type=void]{runInjection}{}				
				}
			\umlClass[pos=\umlRight{pack}, stereotype=Class, posDelta={-5.5, 0},
				refpoint=t]{StrategyBitflipB}{}{
					\umlMethod[visibility=+, type=void]{runInjection}{}					
				}	
			\umlClass[pos=\umlBottomLeft{pack}, stereotype=Class, posDelta={7, 7},
				refpoint=t]{StrategyLoss}{}{
					\umlMethod[visibility=+, type=void]{runInjection}{}					
				}	
			\umlClass[pos=\umlBottomRight{pack}, stereotype=Class, posDelta={-7, 7},
				refpoint=t]{StrategyRandom}{}{
					\umlMethod[visibility=+, type=void]{runInjection}{}					
				}
			\umlClass[pos=\umlBottom{pack}, stereotype=Class, posDelta={0, 7},
				refpoint=t]{...}{}{
					\umlMethod[visibility=+, type=void]{runInjection}{}					
				}				
			\umlInstance{Context}{InjectionStrategy}									
			\umlSubclass{InjectionStrategy}{StrategyBitflip}	
			\umlSubclass{InjectionStrategy}{StrategyBitflipB}
			\umlSubclass{InjectionStrategy}{...}	
			\umlSubclass{InjectionStrategy}{StrategyLoss}
			\umlSubclass{InjectionStrategy}{StrategyRandom}											
		}% End of diagram
	%	\captionsetup{list=false}
	\caption[UML Strategy Pattern]{UML Strategy Pattern}
 	\label{StrategyUML}
\end{figure}



\subsubsection{Strategie Bitflip}

Die erste Strategie tr\"agt den Namen Bitflip und ist in der Regel das aufwendigste Verfahren. Grund daf\"ur ist die individuelle Verwendung der Zufallsfunktion f\"ur jedes einzelne Bit. Auch die Datenmanipulation muss, auf Grundlage des Resultats dieser Funktion entsprechend h\"aufig ausgef\"uhrt werden. Wie der Name Bitflip schon verrät, werden bei dieser Strategie Bits lediglich umgedreht\footnote{flip: 0 zu 1 und 1 zu 0}. Im folgenden Beispiel wurden durch die Zufallsfunktion, die Bits an den Positionen 3,4 und 7 ausgew\"ahlt und entsprechend injiziert. \\

\psline[linecolor=red,linewidth=.1cm,
doublesep=1.5pt]{->}(5.2,1.5)(5.2,0)
\psline[linecolor=red,linewidth=.1cm,
doublesep=1.5pt]{->}(6.8,1.5)(6.8,0)
\psline[linecolor=red,linewidth=.1cm,
doublesep=1.5pt]{->}(11.5,1.5)(11.5,0)
\psline[linecolor=red,linewidth=.1cm,
doublesep=1.5pt]{->}(25.5,1.5)(25.5,0)
\psline[linecolor=red,linewidth=.1cm,
doublesep=1.5pt]{->}(27.1,1.5)(27.1,0)
\psline[linecolor=red,linewidth=.1cm,
doublesep=1.5pt]{->}(31.8,1.5)(31.8,0)


$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\\hline
\end{tabular}
$\dots$
\psline[linewidth=.1cm]{->}(0.5,0)(4,0)
\hspace{2cm}$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 1 & 1 & 0 & 1 & 0 & 1 \\\hline
\end{tabular}
$\dots$

\subsubsection{Strategie BitflipB}

Diese Strategie funktioniert analog zum normalen Bitflip. Einzige Ausnahmen sind die Bearbeitung ganzer Bytes statt einzelner Bits sowie die Möglichkeit der Blockverarbeitung. Die Zufallsfunktion entscheidet diesmal individuell f\"ur jeden Block \"uber dessen Injektion. Wird ein Block zur Injektion ausgew\"ahlt, werden s\"amtliche Bits der darin enthaltenen Bytes gedreht. Wird der Block nicht ausgew\"ahlt, bleiben die Bytes komplett erhalten.\\

$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\\hline
\end{tabular}
$\dots$
\psline[linewidth=.1cm]{->}(0.5,0)(4,0)
\hspace{2cm}$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
1 & 0 & 1 & 1 & 1 & 0 & 0 & 0 \\\hline
\end{tabular}
$\dots$


\subsubsection{Strategie Loss}
Loss ist eine Strategie die das Löschen von ganzen Byte-Blöcken ermöglicht. Wird ein Block im Datensatz zur Injektion ausgewählt, werden sämtliche Bytes des Blocks entfernt. Im Beispiel wird ein Block mit einer Größe von zwei aus dem Datensatz ausgewählt und beide Bytes entfernt.\\

\psbrace[linecolor=red,fillcolor=red, rot=-90,nodesepA=-2pt, nodesepB=17pt](1,2.5)(1,-0.3){injiziert}
\phantom{$\dots$}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\\hline
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\hline
1 & 1 & 1 & 0 & 0 & 1 & 1 & 1 \\\hline
\end{tabular}
$\dots$
\psline[linewidth=.1cm]{->}(0.5,0)(4,0)
\hspace{2cm}$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
1 & 1 & 1 & 0 & 0 & 1 & 1 & 1 \\\hline
\end{tabular}
$\dots$

\subsubsection{Strategie Random}
Die Strategie Random verfügt über einen weiteren Zufallsgenerator. Dieser erstellt für die injizierten Blöcke zufällige Bytes. Die alten Bytes des jeweiligen Blocks werden im Anschluss durch die neu generierten Bytes ersetzt. \\

$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\\hline
\end{tabular}
$\dots$
\psline[linewidth=.1cm]{->}(0.5,0)(4,0)
\hspace{2cm}$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 1 & 0 & 1 & 0 & 0 & 1 \\\hline
\end{tabular}
$\dots$


\subsubsection{StrategyZero}
Diese Strategie funktioniert analog zur Random Strategie. Es werden diesmal allerdings Null-Bytes, statt zufällige Bytes für die Ersetzungen im injizierten Block verwendet. Das folgende Beispiel zeigt ein Byte das bei einer Blockgröße von eins ausgewählt und durch die Zero Strategie injiziert wurde.\\

$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0 & 1 & 0 & 0 & 0 & 1 & 1 & 1 \\\hline
\end{tabular}
$\dots$
\psline[linewidth=.1cm]{->}(0.5,0)(4,0)
\hspace{2cm}$\dots$
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\hline
\end{tabular}
$\dots$


\subsubsection{Strategie None}
Soll keine Injektion ausgef\"uhrt werden, besteht die M\"oglichkeit die Fehlerrate auf 0 oder den Fehlertyp auf NONE zu setzen. Beide Varianten liefern als Resultat die Ausgangsdaten zur\"uck. Einfaches Entfernen des Fehlertyps reicht nicht aus und würde zu einer Fehlermeldung führen.