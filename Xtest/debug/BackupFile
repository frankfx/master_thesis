    def bezierCurve_full(self, t, pList):
        # Curve with level n has n + 1 points : P0 ... Pn
        n = len(pList) - 1
        return self.bezierCurve_full_rec(0, n, t, pList)

    def bezierCurve_full_rec(self, i, n, t, pList):
        if i == n :
            return math.pow(t, i) * pList[i]
        else :
            return self.compute_Bernsteinpolynom(i, n, t) * pList[i] + self.bezierCurve_full_rec(i+1, n, t, pList)
            
    def compute_Bernsteinpolynom(self,i, n, t):
        return math.factorial(n) / ( math.factorial(i) * math.factorial(n-i) ) * math.pow(t,i) * math.pow(1-t, n-i) 

    def __compute_bezier_tangent(self, p1, p2):
        dx = (p2[0] - p1[0]) / 3
        dy = (p2[1] - p1[1]) / 3

        x3 = p1[0] + dx
        y3 = p1[1] + dy

        x4 = x3 + dx
        y4 = y3 + dy
    
        return [x3, y3, 0] , [x4, y4, 0]






      


  '''
    @param: list with points [ [x0,y0,z0] , [x1,y1,z1] , ...  ]
    @return: list with additional control points
    '''
    def createBezierList_for_mapf(self, p_list):
        
        res = []
        for i in range(0, len(p_list)-1) :
            tan1, tan2 = self.__compute_bezier_tangent(p_list[i], p_list[i+1])            
            res.append(p_list[i])
            res.append(tan1)
            res.append(tan2)
            res.append(p_list[i+1])
            
        return res
        
    def createBezierList(self, p_list, step, t=31):
        res = []
        stepf = 4
        for i in range(0, len(p_list), step-1) :  
           # start = p_list[i]
           # end   = p_list[i+1]
           # tan1, tan2 = self.__compute_bezier_tangent(start, end)
 
            hlp = step  if i < len(p_list) -(step-1) else len(p_list) - i
                    
            tmpX = []
            tmpY = []
            tmpZ = []
            k = 0
            for k in range (0, hlp):
                tmpX.append(p_list[i+k][0])
                tmpY.append(p_list[i+k][1])
                tmpZ.append(p_list[i+k][2])      
             
            j = 0     
            for j in range(0, t, 1):
                pos = j*1.0 / t
               # x = self.bezierCurve_full(pos, [ start[0], tan1[0], tan2[0], end[0] ])
               # y = self.bezierCurve_full(pos, [ start[1], tan1[1], tan2[1], end[1] ])
               # z = self.bezierCurve_full(pos, [ start[2], tan1[2], tan2[2], end[2] ])
                    
                x = self.bezierCurve_full(pos, tmpX)
                y = self.bezierCurve_full(pos, tmpY)
                z = self.bezierCurve_full(pos, tmpZ)
                
                res.append([x,y,z])    
        res.append(p_list[len(p_list)-1])
        return res



    def drawProfile_bezier(self, top_prof, bot_prof, shape, step):
        p_list = self.createBezierList(top_prof + bot_prof, step)
        GL.glBegin(shape) 
        for i in range (0, len(p_list), 1) :
            GL.glVertex3f(p_list[i][0], p_list[i][1], p_list[i][2])              
        GL.glEnd()       

        self.drawSkeleton()

    def drawProfile_openGL(self, top_prof, bot_prof, shape, step):
        l_prof = top_prof + bot_prof #self.createBezierList_for_mapf(top_prof + bot_prof)
        for i in range (0, len(l_prof), step-1):
            tmp = []
            hlp = step  if i < len(l_prof) -(step-1) else len(l_prof) - i
                
            for b in range (i, i + hlp, 1) :
                tmp.append(l_prof[b])
                
            if hlp < step and self.flag_view == Renderer.CLOSED :
                tmp.append(l_prof[0])
    
            GL.glMap1f(GL.GL_MAP1_VERTEX_3, 0.0, 1.0, tmp)
    
            j = 0
            GL.glBegin(GL.GL_LINE_STRIP)
            for j in range (0, 31, 1):
                GL.glEvalCoord1f(j/30.0)
            GL.glEnd()
            if (hlp < step) :
                break






    def drawTriangle(self):
        GL.glBegin(GL.GL_TRIANGLES)
        GL.glVertex3f(0, 0, 0)
        GL.glVertex3f(0.5, 1, 0)
        GL.glVertex3f(1, 0, 0)
        GL.glEnd()

        

    def __computeCamberAndLeadingEdge(self, plist):
        n = 4                   # for safty
                                # plist = getCompleteList
        axis0 = []              # result list
        idx_b = 0               # index botList first point
        idx_t = len(plist) - 1  # index topList first point
        
        # for all bottom points 
        for idx_b in range(0, idx_t) : 
            if not idx_b + n < idx_t : break

            # get x, y, z of bottom
            x_b = plist[idx_b][0]
            y_b = plist[idx_b][1]
            z_b = plist[idx_b][2]
            
            # set i to last possible value of top points (trailing edge)
            i = len(plist)-1 if idx_t + n > len(plist)-1 else idx_t + n
            
            # save idx_t
            tmp_idx_t = idx_t
            
            # dist help value, set to None
            dist=-1.0
            
            # look for top points
            for i in range(i, idx_b + n, -1) :
                x_t = plist[i][0]
                y_t = plist[i][1]
                z_t = plist[i][2]                
                
                # cur_dist = distance between current bot and top point
                cur_dist = ((x_t-x_b)*(x_t-x_b))+((y_t-y_b)*(y_t-y_b))
                
                # find closest distance
                if ((dist < 0.0) or ((cur_dist <= dist) and (cur_dist>1e-10))) :
                    idx_t = i 
                    dist = cur_dist
                if ((dist >= 0.0) and (cur_dist > dist)) :
                    break
                
            if (dist >= 0.0) :
                # stop if non valid closest point found
                if (idx_t - idx_b <= n+1) :
                    idx_t = tmp_idx_t 
                    break 
                
                x_t = plist[idx_t][0]
                y_t = plist[idx_t][1]
                z_t = plist[idx_t][2]
                
                axis0.append([0.5*(x_b + x_t), 0.5*(y_b + y_t), 0.5*(z_b + z_t)])
    
        # =======================================================================
        # find leading edge point (the farest point from last found axis point)
        axis0 , leadingPoint_axis0 = self.__addLeadingEdgePoint(axis0, plist, idx_b, idx_t)

        # =======================================================================
        # find axis1: midpoint of i0=(ix1,pnt.num) i1=find closest from (0,ix1) 

        axis1 = []
        idx_b = 0
        idx_t = len(plist) - 1
        
        for idx_t in range(idx_t, idx_b, -1) :
            if not idx_t > idx_b + n : break
            
            x_t = plist[idx_t][0]
            y_t = plist[idx_t][1]           
            z_t = plist[idx_t][2]
            
            i = 0 if idx_b-n < 0 else idx_b-n
          
            tmp_idx_b = idx_b
            
            dist = -1.0
            
            for i in range (i, idx_t-n):
                x_b = plist[i][0]
                y_b = plist[i][1]
                z_b = plist[i][2]
                
                cur_dist = ((x_b-x_t)*(x_b-x_t))+((y_b-y_t)*(y_b-y_t));
            
                if ((dist < 0.0) or ((cur_dist <= dist) and (cur_dist > 1e-10))) :
                    idx_b = i
                    dist = cur_dist
                    
                if ((dist >= 0.0) and (cur_dist > dist)): 
                    break                
            
            if dist >= 0.0 :
                if idx_t - idx_b <= n+2:
                    idx_b = tmp_idx_b
                    break       # stop if non valid closest point found
                
                x_b = plist[idx_b][0]
                y_b = plist[idx_b][1]
                z_b = plist[idx_b][2]
            
                axis1.append([0.5*(x_t + x_b), 0.5*(y_t+y_b), 0.5*(z_t+z_b)])    
    
   
        # =======================================================================
        # find leading edge point (the farest point from last found axis point)      
        axis1, leadingPoint_axis1 = self.__addLeadingEdgePoint(axis1, plist, idx_b, idx_t)
       
        # =======================================================================
        # find axis: midpoint of i0=<0-axis0.num) i1=find closest from <0-axis1.num) 

        idx_b = 0
        idx_t = 0
        axis = []
        
        for idx_b in range(0, len(axis0)):
            x_b = axis0[idx_b][0]
            y_b = axis0[idx_b][1]
            z_b = axis0[idx_b][2]
            
            i = idx_t
            
            dist = -1.0
            
            for i in range(i, len(axis1)) :
                x_t = axis1[i][0]
                y_t = axis1[i][1]
                z_t = axis1[i][2]
                
                cur_dist = ((x_t-x_b)*(x_t-x_b))+((y_t-y_b)*(y_t-y_b))
                
                if ((dist < 0.0) or (cur_dist <= dist)) :
                    idx_t = i
                    dist = cur_dist
            if (dist >= 0.0) :
                x_t = axis1[idx_t][0]
                y_t = axis1[idx_t][1]
                z_t = axis1[idx_t][2]
                
                axis.append([0.5*(x_b+x_t), 0.5*(y_b+y_t), 0.5*(z_b+z_t)])
  
        return axis , self.__getCenterPoint(leadingPoint_axis0, leadingPoint_axis1)
  
    
    # find leading edge point (the farest point from last found axis point)
    def __addLeadingEdgePoint(self, axis, plist, idx_0, idx_1):
        #last found axis point
        x_b = axis[len(axis)-1][0]
        y_b = axis[len(axis)-1][1]
    
        dist = -1.0
        i = idx_0
        res_idx = -1
        
        for i in range(i, idx_1 + 1) :
            x_t = plist[i][0]
            y_t = plist[i][1]
            
            cur_dist =((x_t-x_b)*(x_t-x_b))+((y_t-y_b)*(y_t-y_b))
            
            if (cur_dist > dist) : 
                res_idx = i
                dist = cur_dist
        
        axis.append(plist[res_idx])
        return axis , plist[res_idx]         
        
        
        
        
    '''
    ?????????????????????????????????????????????????????
    Bug - nachragen wie line bestimmt wird
    ????????????????????????????????????????????????????
    @param p1: point of topList
    @param plist: botList
    @return: Point in the center of topList and botList at position x  
    '''
    def __computePoint(self, p1, plist):

        idx_r  , idx_l   = -1   , -1
        flag_l , flag_r = False , False

        for i in range(0 , len(plist)) :
            if plist[i][0] <= p1[0]:
                if not flag_l :
                    idx_l = i
                    flag_l = True
                elif plist[i][0] > plist[idx_l][0]:
                    idx_l = i

            if plist[i][0] >= p1[0] :
                if not flag_r:
                    idx_r = i
                    flag_r = True
                elif plist[i][0] < plist[idx_r][0] :
                    idx_r = i

        if idx_r == -1 or idx_l == -1 :
            self.__debug("None in dataSet.__computePoint\nPoint " + str(p1) + ' not in List\n'  + str(plist))

            mini, maxi = self.get_min_max_of_List(plist, 0)
            p_r = maxi if idx_r == -1 else plist[idx_r]
            p_l = mini if idx_l == -1 else plist[idx_l]

            p_new = self.__computePointOnLine(p1[0], p_l, p_r)
            return [p1[0], p1[1] - (p1[1] - p_new[1]) / 2.0, p1[2]]

        elif idx_r == idx_l :
            y = p1[1] - (p1[1] - plist[idx_l][1]) / 2
            return [p1[0], y, p1[2]]

        p_new = self.__computePointOnLine(p1[0], plist[idx_l], plist[idx_r])
        return [p1[0], p1[1] - (p1[1] - p_new[1]) / 2.0, p1[2]]        
        
        
        
        
        
        
        
        
    '''
    @param: uid from cpacs
    @param: sort_desc boolean flag for splitting option
    @return: lists for top and bottom profile in format [ [x0,y0,z0] , [x1,y1,z1] , ...  ]
    [3,2,1,0,1,2,3] --> [3,2,1] , [0,1,2,3] --> topList, botList
    [0,1,2,3,2,1,0] --> [0,1,2] , [3,2,1,0]
    '''
    def __createPointList_old(self, uid, sort_desc = True):
        vecX = self.tixi.getVectorX(uid)
        vecY = self.tixi.getVectorZ(uid)
        vecZ = self.tixi.getVectorY(uid)
        
        l_top = []
        l_bot = []
        for i in range(0, len(vecX)-1, 1) :
            if sort_desc:
                if(vecX[i] > vecX[i+1]) :
                    l_bot.append([ vecX[i], vecY[i], vecZ[i] ])
                else : 
                    l_bot.append([ vecX[i], vecY[i], vecZ[i] ])
                    break
            else :
                if vecX[i] < vecX[i+1] :
                    l_bot.append([ vecX[i], vecY[i], vecZ[i] ])
                else:
                    l_bot.append([ vecX[i], vecY[i], vecZ[i] ])
                    break                    

        for j in range(i, len(vecX), 1) :
            l_top.append([ vecX[j], vecY[j], vecZ[j] ])
        
        return l_bot , l_top
        