    def bezierCurve_full(self, t, pList):
        # Curve with level n has n + 1 points : P0 ... Pn
        n = len(pList) - 1
        return self.bezierCurve_full_rec(0, n, t, pList)

    def bezierCurve_full_rec(self, i, n, t, pList):
        if i == n :
            return math.pow(t, i) * pList[i]
        else :
            return self.compute_Bernsteinpolynom(i, n, t) * pList[i] + self.bezierCurve_full_rec(i+1, n, t, pList)
            
    def compute_Bernsteinpolynom(self,i, n, t):
        return math.factorial(n) / ( math.factorial(i) * math.factorial(n-i) ) * math.pow(t,i) * math.pow(1-t, n-i) 

    def __compute_bezier_tangent(self, p1, p2):
        dx = (p2[0] - p1[0]) / 3
        dy = (p2[1] - p1[1]) / 3

        x3 = p1[0] + dx
        y3 = p1[1] + dy

        x4 = x3 + dx
        y4 = y3 + dy
    
        return [x3, y3, 0] , [x4, y4, 0]






      


  '''
    @param: list with points [ [x0,y0,z0] , [x1,y1,z1] , ...  ]
    @return: list with additional control points
    '''
    def createBezierList_for_mapf(self, p_list):
        
        res = []
        for i in range(0, len(p_list)-1) :
            tan1, tan2 = self.__compute_bezier_tangent(p_list[i], p_list[i+1])            
            res.append(p_list[i])
            res.append(tan1)
            res.append(tan2)
            res.append(p_list[i+1])
            
        return res
        
    def createBezierList(self, p_list, step, t=31):
        res = []
        stepf = 4
        for i in range(0, len(p_list), step-1) :  
           # start = p_list[i]
           # end   = p_list[i+1]
           # tan1, tan2 = self.__compute_bezier_tangent(start, end)
 
            hlp = step  if i < len(p_list) -(step-1) else len(p_list) - i
                    
            tmpX = []
            tmpY = []
            tmpZ = []
            k = 0
            for k in range (0, hlp):
                tmpX.append(p_list[i+k][0])
                tmpY.append(p_list[i+k][1])
                tmpZ.append(p_list[i+k][2])      
             
            j = 0     
            for j in range(0, t, 1):
                pos = j*1.0 / t
               # x = self.bezierCurve_full(pos, [ start[0], tan1[0], tan2[0], end[0] ])
               # y = self.bezierCurve_full(pos, [ start[1], tan1[1], tan2[1], end[1] ])
               # z = self.bezierCurve_full(pos, [ start[2], tan1[2], tan2[2], end[2] ])
                    
                x = self.bezierCurve_full(pos, tmpX)
                y = self.bezierCurve_full(pos, tmpY)
                z = self.bezierCurve_full(pos, tmpZ)
                
                res.append([x,y,z])    
        res.append(p_list[len(p_list)-1])
        return res



    def drawProfile_bezier(self, top_prof, bot_prof, shape, step):
        p_list = self.createBezierList(top_prof + bot_prof, step)
        GL.glBegin(shape) 
        for i in range (0, len(p_list), 1) :
            GL.glVertex3f(p_list[i][0], p_list[i][1], p_list[i][2])              
        GL.glEnd()       

        self.drawSkeleton()

    def drawProfile_openGL(self, top_prof, bot_prof, shape, step):
        l_prof = top_prof + bot_prof #self.createBezierList_for_mapf(top_prof + bot_prof)
        for i in range (0, len(l_prof), step-1):
            tmp = []
            hlp = step  if i < len(l_prof) -(step-1) else len(l_prof) - i
                
            for b in range (i, i + hlp, 1) :
                tmp.append(l_prof[b])
                
            if hlp < step and self.flag_view == Renderer.CLOSED :
                tmp.append(l_prof[0])
    
            GL.glMap1f(GL.GL_MAP1_VERTEX_3, 0.0, 1.0, tmp)
    
            j = 0
            GL.glBegin(GL.GL_LINE_STRIP)
            for j in range (0, 31, 1):
                GL.glEvalCoord1f(j/30.0)
            GL.glEnd()
            if (hlp < step) :
                break






    def drawTriangle(self):
        GL.glBegin(GL.GL_TRIANGLES)
        GL.glVertex3f(0, 0, 0)
        GL.glVertex3f(0.5, 1, 0)
        GL.glVertex3f(1, 0, 0)
        GL.glEnd()
